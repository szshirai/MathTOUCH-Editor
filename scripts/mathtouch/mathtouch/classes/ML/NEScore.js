MathTOUCH.node = function(c,r) {    this.letter=c;    this.projectionScore=new Object();	this.down=null;	this.right=r;}MathTOUCH.NEScore = function(){    var mturl=null;    var VkeyMax=KTB.getKeymax();    var VkeyTotal=KTB.getTotalSymbol();    var OkeyMax=OTB.getKeyTotal();    var OkeyTotal=OTB.getTotalOperator();    this.MAX=10;    this.SCMax=20;	var keyID=new Array(VkeyTotal+OkeyTotal);    var NodeScore=new Array(VkeyTotal+OkeyTotal);    var TopEdgeScore=new Array(VkeyTotal+OkeyTotal);    var EdgeScore=new Array(OkeyTotal);    console.log("OkeyTotal="+OkeyTotal+",EdgeScore.len="+EdgeScore.length);    var root=null;    var addNodeProjScore=function(str,kid,point){        var SCMax=20;        var index=0;		if(root==null) {			root = new MathTOUCH.node('\n'.charCodeAt(0),null);		}        var temp,tempBack,pred;        temp=tempBack=root;        if(str.length==0){            str="EMP";        }        while(index<str.length){            if(temp.down == null) {				temp.down = new MathTOUCH.node(str.charCodeAt(index),null);				temp = temp.down;			}			else {				pred = temp;				temp = temp.down;				if(str.charCodeAt(index) < temp.letter) {					temp = new MathTOUCH.node(str.charCodeAt(index),temp);					pred.down = temp;				}				else if(str.charCodeAt(index) > temp.letter) {					while(temp != null && str.charCodeAt(index) > temp.letter) {						tempBack = temp;						temp = temp.right;					}                    if(temp==null){                        temp=new MathTOUCH.node(str.charCodeAt(index),null);                        tempBack.right = temp;                    }					else if(str.charCodeAt(index) != temp.letter) {						temp = new MathTOUCH.node(str.charCodeAt(index), temp);						tempBack.right = temp;					}				}			}			index++;        }        var myscore=temp.projectionScore[kid];        if(myscore==0||myscore==undefined) temp.projectionScore[kid]=point;        else if(myscore<SCMax||point<0) temp.projectionScore[kid]=myscore+point;    }    var getNodeProjScore=function(str,kid){        var index=0;		if(root==null) {			return 0;		}        var ans=0;        var temp,tempBack,pred;        temp=tempBack=root;        if(str.length==0){            str="EMP";        }        while(index<str.length){            if(temp.down == null) {				return 0;			}			else {				pred = temp;				temp = temp.down;				if(str.charCodeAt(index) < temp.letter) {					return 0;				}				else if(str.charCodeAt(index) > temp.letter) {					while(temp != null && str.charCodeAt(index) > temp.letter) {						tempBack = temp;						temp = temp.right;					}                    if(temp==null) return 0;					else if(str.charCodeAt(index) != temp.letter) {						return 0;					}				}			}			index++;        }        var myscore=temp.projectionScore[kid];        if(myscore==0||myscore==undefined) return 0;        else return myscore;    }var xmlLoad=function(fname){	$.ajax({		   url:fname,		   type:'get',		   dataType:'xml',		   timeout:1000,		   success:parse_xml		   });}var mindex=0;var parse_xml=function(xml,status){	if(status!='success') {alert("XMLread error");return;}	$(xml).find('MathID').each(mathid_load);    $(xml).find('NodeScore').each(nodescore_load);    $(xml).find('TopScore').each(topscore_load);    $(xml).find('EdgeScore').each(edgescore_load);    $(xml).find('KeyWordScore').each(keywordscore_load);    console.log("keyID2="+keyID[2]+",keyID500="+keyID[500]+",NodeScore[38]="+NodeScore[38]+",TopScore[1]="+TopEdgeScore[1]+",EdgeScore[0][100]="+EdgeScore[0][100]+",VkeyMax="+VkeyMax+",VkeyTotal="+VkeyTotal+",OkeyMax="+OkeyMax+",OkeyTotal="+OkeyTotal);}var mathid_load=function(){    mindex=0;	$(this).find('Data').each(mdata_load);}var mdata_load=function(){	var $mid = $(this).text();	keyID[mindex]=$mid;	mindex++;}var nodeindex=0;var nodescore_load=function(){    nodeindex=0;	$(this).find('Data').each(ndata_load);}var ndata_load=function(){	var $mid = $(this).text();	NodeScore[nodeindex]=new Number($mid);	nodeindex++;}var topindex=0;var topscore_load=function(){    topindex=0;	$(this).find('Data').each(tdata_load);}var tdata_load=function(){	var $mid = $(this).text();	TopEdgeScore[topindex]=new Number($mid);	topindex++;}var edgeindex=0;var edgescore_load=function(){	$(this).find('Edge').each(edge_load);}var edge_load=function()	{	var $pid = $(this).find('parent').text();    edgeindex=new Number($pid);    $(this).find('Data').each(edgekey_load);}var edgekey_load=function()	{	var $mid = $(this).find('mathIndex').text();    var $sc = $(this).find('score').text();	EdgeScore[edgeindex][$mid]=new Number($sc);}var mykeyword="";var keywordscore_load=function(){	$(this).find('MathNode').each(mathnode_load);}var mathnode_load=function()	{	var $key = $(this).find('KeyWord').text();    mykeyword=$key;    $(this).find('Data').each(mathkey_load);}var mathkey_load=function()	{	var $mid = $(this).find('mathIndex').text();    var $sc = $(this).find('score').text();	addNodeProjScore(mykeyword,$mid,new Number($sc));}	this.readTable=function(fname){        root=null;        if(mturl==null) mturl="../mathtouch/";        console.log(mturl+fname+".xml");        xmlLoad(mturl+fname+".xml");	}    var setLocalStorage=function(key, value) {        if (!window.localStorage){alert("Not use localStrage"); return;}        try {            var save=localStorage.setItem(key, value);        } catch (err) {            console.error(err);            alert("localStrage error: "+err);        }    }    this.writeXML=function(){		var str="<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";        str=str+"\n";        str=str+"<info>";        str=str+"\n";        str=str+"<MathID>";        str=str+"\n";		for(var i=0;i<VkeyTotal+OkeyTotal;i++){            str=str+"<Data>"+keyID[i]+"</Data>";            str=str+"\n";        }        str=str+"</MathID>";        str=str+"\n";        str=str+"<NodeScore>";        str=str+"\n";        for(var i=0;i<VkeyTotal+OkeyTotal;i++){            str=str+"<Data>"+NodeScore[i]+"</Data>";            str=str+"\n";        }        str=str+"</NodeScore>";        str=str+"\n";        str=str+"<TopScore>";        str=str+"\n";        for(var i=0;i<VkeyTotal+OkeyTotal;i++){            str=str+"<Data>"+TopEdgeScore[i]+"</Data>";            str=str+"\n";        }        str=str+"</TopScore>";        str=str+"\n";        str=str+"<EdgeScore>";        str=str+"\n";        for(var i=0;i<OkeyTotal;i++){            str=str+"<Edge><parent>"+i+"</parent>";            str=str+"\n";            for(var key in EdgeScore[i]){                str=str+"<Data><mathIndex>"+key+"</mathIndex><score>"+EdgeScore[i][key]+"</score></Data>";                str=str+"\n";            }            str=str+"</Edge>";            str=str+"\n";        }        str=str+"</EdgeScore>";        str=str+"\n";        str=str+"<KeyWordScore>";        str=str+"\n";        str=str+this.printNodeFromStrXML(root,"");        str=str+"</KeyWordScore>";        str=str+"\n";        str=str+"</info>";        str=str+"\n";        setLocalStorage("myscore", str);        return str;	}    this.printNodeFromStrXML=function(nd,fromXML){        var ans="";        var lll;        if(nd==null) return ans;        if(nd.letter=='<'.charCodeAt(0)) lll="&lt;";        else if(nd.letter=='>'.charCodeAt(0)) lll="&gt;";        else lll=String.fromCharCode(nd.letter);        var str="";        for(var keyID in nd.projectionScore){            str+="<Data><mathIndex>"+keyID+"</mathIndex><score>"+nd.projectionScore[keyID]+"</score></Data>\n";        }        if(str.length>0){            ans="<MathNode>\n<KeyWord>"+fromXML+lll+"</KeyWord>\n";            ans+=str;            ans+="</MathNode>\n";        }        var temp=nd.down;        while(temp!=null){            if(nd.letter<' '.charCodeAt(0)) ans+=this.printNodeFromStrXML(temp,fromXML);            else ans+=this.printNodeFromStrXML(temp,fromXML+lll);            temp=temp.right;        }        return ans;    }    this.resetTable=function(){        console.log("NES reset.");        this.clearTable();        this.readTable("SCORE4000_220704");    }    this.clearTable=function(){        console.log("NES clearTable.");        for(var i=0;i<VkeyTotal+OkeyTotal;i++){            NodeScore[i]=0;        }        for(var i=0;i<VkeyTotal+OkeyTotal;i++){            TopEdgeScore[i]=0;        }        for(var i=0;i<OkeyTotal;i++){            EdgeScore[i]=new Object();        }        var index=0;        for(var i=0;i<VkeyMax;i++){            var len=KTB.keyLengthOf(i);            for(var j=0;j<len;j++) keyID[index++]=i*256+j;        }        for(var i=0;i<OkeyMax;i++){            var len=OTB.getOpeLength(i);            for(var j=0;j<len;j++) keyID[index++]=i*100+j;        }        root=null;            }    this.init=function(xmlurl){        mturl=xmlurl;        this.clearTable();        var myscore=null;                if(myscore ==null){            this.readTable("SCORE4000_220704");            console.log("ML xml read");        }        else{            parse_xml(myscore,"success");            console.log("localstrage");        }    }    this.printNodeFromStr=function(nd,fromXML){        var ans="";        for(var e in nd.projectionScore){            ans+=e+":"+nd.projectionScore[e]+",";        }        if(ans.length>0) ans=fromXML+String.fromCharCode(nd.letter)+"@@@"+ans+"\n";        var temp=nd.down;        while(temp!=null){            if(nd.letter<' '.charCodeAt(0)) ans+=this.printNodeFromStr(temp,fromXML);            else ans+=this.printNodeFromStr(temp,fromXML+String.fromCharCode(nd.letter));            temp=temp.right;        }        return ans;    }    this.printRoot=function(){        if(root==null) return "";        return this.printNodeFromStr(root,"");    }    this.makeTop10from=function(ex){        var ans=new MathTOUCH.Top10();        ans.setMax(this.MAX);        var ko;        var obj;        if(ex.cnum==0){            if(ex.type==MathTOUCH.EMP&&ex.inputWord==""){                ans.rankIn(ex.copy(),1);            }            else if(ex.type==MathTOUCH.EMP&&ex.inputWord==" "){                if(ex.state==0){                    for(var i=0;i<6;i++){                        obj=ex.copy();                        obj.order=i;                        obj.val=KTB.getWord(ex.key,i);                        ans.rankIn(obj,this.countEXtreeScore(obj));                    }                }                else{                    ans.rankIn(ex.copy(),this.countEXtreeScore(ex));                }            }            else if(ex.type==MathTOUCH.NUM){                ans.rankIn(ex.copy(),this.countEXtreeScore(ex));            }            else if(ex.type<=MathTOUCH.SYM && ex.key>=0){                if(ex.state==0){                    for(var i=0;i<KTB.keyLengthOf(ex.key);i++){                        obj=ex.copy();                        obj.order=i;                        obj.type=KTB.getType(ex.key,i);                        obj.val=KTB.getWord(ex.key,i);                        ans.rankIn(obj,this.countEXtreeScore(obj));                    }                }                else{                    ans.rankIn(ex.copy(),this.countEXtreeScore(ex));                }            }            else{                alert("makeTop10 cnum=0 Error / NEScore.java");                return ans;            }        }        else if(ex.rownum*ex.colnum>0){            if(ex.state==0){                var Mnum=ex.rownum*ex.colnum;                var elems=new Array(Mnum);                var LEN=new Array(Mnum);                for(var i=0;i<Mnum;i++){                    elems[i]=this.makeTop10from(ex.ch[i]);                    LEN[i]=elems[i].getLastNumber();                }                var vidx=this.leastIndices(3*this.MAX,LEN);                var idx=new Array(Mnum);                for(var k=0;k<vidx.length;k++){                    var elem=new Array(Mnum);                    idx=vidx[k];                    for(var i=0;i<Mnum;i++){                        elem[i]=elems[i].getEXtreeAt(idx[i]).copy();                    }                    obj=new EXtreeMat0(0,ex.rownum,ex.colnum,elem,"MAT");                    ans.rankIn(obj,this.countScore(obj));                }            }            else{                ans.rankIn(ex,this.countEXtreeScore(ex));            }        }        else if(ex.cnum==1){            var ch0;            if(ex.state==0){                var len=OTB.getOpeLength(ex.key);                ch0=this.makeTop10from(ex.ch[0]);                var tlen=ch0.getLastNumber();                for(var i=0;i<len;i++){                    for(var j=0;j<tlen;j++){                        if(OTB.getOpeType(ex.key,i)==ex.type){                            obj=new EXtree1(0,ex.key,i,ch0.getEXtreeAt(j).copy(),ex.inputWord);                            ans.rankIn(obj,this.countScore(obj));                        }                    }                }            }            else{                ch0=this.makeTop10from(ex.ch[0]);                var tlen=ch0.getLastNumber();                for(var j=0;j<tlen;j++){                    obj=new EXtree1(2,ex.key,ex.order,ch0.getEXtreeAt(j).copy(),ex.inputWord);                    ans.rankIn(obj,this.countScore(obj));                }            }        }        else if(ex.cnum==2){            var ch0,ch1;            if(ex.state==0){                var len=OTB.getOpeLength(ex.key);                ch0=this.makeTop10from(ex.ch[0]);                ch1=this.makeTop10from(ex.ch[1]);                var tlen0=ch0.getLastNumber();                var tlen1=ch1.getLastNumber();                var ch0tmp;                for(var i=0;i<len;i++){                    for(var j=0;j<tlen0;j++){                        for(var k=0;k<tlen1;k++){                            if(OTB.getOpeType(ex.key,i)==ex.type){                                ch0tmp=ch0.getEXtreeAt(j);                                if(ex.key==0&&i==2){                                    if(ch0tmp.type==MathTOUCH.OP2C&&ch0tmp.key==0&&ch0tmp.order==3){                                        obj=new EXtree2(0,ex.key,i,ch0tmp.copy(),ch1.getEXtreeAt(k).copy(),ex.inputWord);                                        ans.rankIn(obj,this.countScore(obj));                                    }                                }                                else{                                    obj=new EXtree2(0,ex.key,i,ch0tmp.copy(),ch1.getEXtreeAt(k).copy(),ex.inputWord);                                    ans.rankIn(obj,this.countScore(obj));                                }                            }                        }                    }                }            }            else{                ch0=this.makeTop10from(ex.ch[0]);                ch1=this.makeTop10from(ex.ch[1]);                var tlen0=ch0.getLastNumber();                var tlen1=ch1.getLastNumber();                var ch0tmp;                for(var j=0;j<tlen0;j++){                    for(var k=0;k<tlen1;k++){                        ch0tmp=ch0.getEXtreeAt(j);                        if(ex.key==0&&ex.order==2){                            if(ch0tmp.type==MathTOUCH.OP2C&&ch0tmp.key==0&&ch0tmp.order==3){                                obj=new EXtree2(2,ex.key,ex.order,ch0tmp.copy(),ch1.getEXtreeAt(k).copy(),ex.inputWord);                                ans.rankIn(obj,this.countScore(obj));                            }                        }                        else{                            obj=new EXtree2(2,ex.key,ex.order,ch0tmp.copy(),ch1.getEXtreeAt(k).copy(),ex.inputWord);                            ans.rankIn(obj,this.countScore(obj));                        }                    }                }            }        }        else if(ex.cnum==3){            var ch0,ch1,ch2;            if(ex.state==0){                var len=OTB.getOpeLength(ex.key);                ch0=this.makeTop10from(ex.ch[0]);                ch1=this.makeTop10from(ex.ch[1]);                ch2=this.makeTop10from(ex.ch[2]);                var tlen0=ch0.getLastNumber();                var tlen1=ch1.getLastNumber();                var tlen2=ch2.getLastNumber();                for(var i=0;i<len;i++){                    for(var j=0;j<tlen0;j++){                        for(var k=0;k<tlen1;k++){                            for(var l=0;l<tlen2;l++){                                if(OTB.getOpeType(ex.key,i)==ex.type){                                    obj=new EXtree3(0,ex.key,i,ch0.getEXtreeAt(j).copy(),ch1.getEXtreeAt(k).copy(),ch2.getEXtreeAt(l).copy(),ex.inputWord);                                    ans.rankIn(obj,this.countScore(obj));                                }                            }                        }                    }                }            }            else{                ch0=this.makeTop10from(ex.ch[0]);                ch1=this.makeTop10from(ex.ch[1]);                ch2=this.makeTop10from(ex.ch[2]);                var tlen0=ch0.getLastNumber();                var tlen1=ch1.getLastNumber();                var tlen2=ch2.getLastNumber();                for(var j=0;j<tlen0;j++){                    for(var k=0;k<tlen1;k++){                        for(var l=0;l<tlen2;l++){                            obj=new EXtree3(2,ex.key,ex.order,ch0.getEXtreeAt(j).copy(),ch1.getEXtreeAt(k).copy(),ch2.getEXtreeAt(l).copy(),ex.inputWord);                            ans.rankIn(obj,this.countScore(obj));                        }                    }                }            }        }        else{alert("makeTop10 else");            ans.rankIn(ex.copy(),this.countScore(ex));        }        return ans;    }            this.getVkeyIndexByID=function(id){        for(var i=0;i<VkeyTotal;i++){            if(keyID[i]==id) return i;        }        return -1;    }        this.getOkeyIndexByID=function(id){        for(var i=VkeyTotal;i<VkeyTotal+OkeyTotal;i++){            if(keyID[i]==id) return i;        }        return -1;    }    this.getIndexOf=function(ex){        if(ex==null){alert("My error");return null;}        if(ex.cnum==0){            if(ex.type==MathTOUCH.EMP) return -2;            else if(ex.type==MathTOUCH.NUM){                return -1;            }            else{if(ex.key==undefined)                return KTB.VIDof(ex.key,ex.order);            }        }        else if(ex.rownum*ex.colnum>0){            return -100;        }        else{            return( OTB.getOID(ex.key,ex.order)+VkeyTotal);        }    }	this.addNodeEdgeScore=function(ex,point){		var vID;        if(ex.cnum==0){            if(ex.type==MathTOUCH.NUM){                addNodeProjScore(ex.inputWord,"n"+ex.val,point);            }            else if(ex.type==MathTOUCH.EMP){            }            else if((vID=KTB.VIDof(ex.key,ex.order))>=0){                if(NodeScore[vID]<this.SCMax||point<0) NodeScore[vID]+=point;                addNodeProjScore(ex.inputWord,vID,point);            }            else{                alert("addScore Error / NEScore.java");            }        }        else if(ex.rownum*ex.colnum>0){                    }        else{            if((vID=OTB.getOID(ex.key,ex.order))>=0){                if(NodeScore[vID+VkeyTotal]<this.SCMax||point<0) NodeScore[vID+VkeyTotal]+=point;                addNodeProjScore(ex.inputWord,(vID+VkeyTotal),point);                for(var i=0;i<ex.cnum;i++){                    var exindex=this.getIndexOf(ex.ch[i]);                    var toIndex="error";                    if(exindex>=0) toIndex=""+(i*10000+exindex);                    else if(exindex==-1) toIndex=i+"n"+ex.ch[i].val;                    var score=EdgeScore[vID][toIndex];                    if(score==null||score==undefined) EdgeScore[vID][toIndex]=point;                    else if(score<this.SCMax||point<0) EdgeScore[vID][toIndex]=(score+point);                }            }            else{                alert("addScore Error2 / NEScore.java");            }        }	}    this.addEXtreeScore=function(ex,point){        if(ex.cnum==0){            this.addNodeEdgeScore(ex,point);        }        else if(ex.rownum*ex.colnum>0){            for(var i=0;i<ex.cnum;i++) this.addEXtreeScore(ex.ch[i],point);        }        else{            this.addNodeEdgeScore(ex,point);            for(var i=0;i<ex.cnum;i++) this.addEXtreeScore(ex.ch[i],point);        }    }    this.addScore=function(ex,point){        var vID;        this.addEXtreeScore(ex,point);        if(ex.cnum>0&&(vID=OTB.getOID(ex.key,ex.order))>=0){            if(TopEdgeScore[vID]<this.SCMax||point<0) TopEdgeScore[vID]+=point;        }    }    this.countNodeEdgeScore=function(ex){        var vID;        var ans=0;        if(ex.cnum==0){            if(ex.type==MathTOUCH.EMP){                ans=-20;            }            else if(ex.type==MathTOUCH.NUM){                var nlen=ex.val.length;                ans=1;                ans=ans*nlen;                if(nlen>1){                    ans=ans+this.SCMax*3*(nlen-1);                }            }            else if((vID=KTB.VIDof(ex.key,ex.order))>=0){                var nlen=ex.inputWord.length;                var sps=getNodeProjScore(" ",VkeyTotal);                if(sps<0) sps=1;                ans=getNodeProjScore(ex.inputWord,vID);                ans=ans*nlen;                if(nlen>1){                    ans=ans+this.SCMax*3*(nlen-1);                }            }            else{                alert("countScore Error / NEScore.js:"+ex.val+","+ex.inputWord);            }        }        else if(ex.rownum*ex.colnum>0){            return 0;        }        else{            ans=0;            if((vID=OTB.getOID(ex.key,ex.order))>=0){                var nlen=ex.inputWord.length;                var olen=ex.cnum*2;                ans=getNodeProjScore(ex.inputWord,(vID+VkeyTotal));                ans=ans*nlen;                if(nlen>1){                    ans=ans+this.SCMax*3*(nlen-1);                    ans=ans+this.SCMax*olen;                }                for(var i=0;i<ex.cnum;i++){                    if(ex.ch[i]==null){return null;}                    var exindex=this.getIndexOf(ex.ch[i]);                    var toIndex="error";                    if(exindex>=0) toIndex=""+(i*10000+exindex);                    else if(exindex==-1) toIndex=i+"n"+ex.ch[i].val;                    else if(exindex==-2) toIndex="";                    var score;                    if(toIndex.length>0) score=EdgeScore[vID][toIndex];                    else score=-20;                    if(score!=null&&score!=undefined){ ans+=score;                    }                }            }            else{                alert("addScore Error / NEScore.java");                return null;            }        }        return ans;    }    this.countScoreLevel2=function(ex){        var ans=0;        if(ex.cnum==0) ans=this.countNodeEdgeScore(ex);        else if(ex.rownum*ex.colnum>0){            for(var i=0;i<ex.cnum;i++) ans+=this.countNodeEdgeScore(ex.ch[i]);        }        else{            ans=this.countNodeEdgeScore(ex);            for(var i=0;i<ex.cnum;i++) ans+=this.countNodeEdgeScore(ex.ch[i]);        }        return ans;    }    this.countEXtreeScore=function(ex){        var ans=0;        if(ex.cnum==0) ans=this.countNodeEdgeScore(ex);        else if(ex.rownum*ex.colnum>0){            for(var i=0;i<ex.cnum;i++) ans+=this.countEXtreeScore(ex.ch[i]);        }        else{            ans=this.countNodeEdgeScore(ex);            for(var i=0;i<ex.cnum;i++) ans+=this.countEXtreeScore(ex.ch[i]);        }        return ans;    }    this.countScore=function(ex){        var ans=this.countEXtreeScore(ex);        var vID=0;        if(ex.cnum>0&&ex.type!=MathTOUCH.MAT){            vID=OTB.getOID(ex.key,ex.order);            if(vID>=0){                ans+=TopEdgeScore[vID];            }        }        return ans;    }    this.printTable=function(){		var str=""+keyID[0];		for(var i=1;i<VkeyTotal+OkeyTotal;i++) str=str+","+keyID[i];        str+="\n";        str+=NodeScore[0];        for(var i=1;i<VkeyTotal+OkeyTotal;i++) str=str+","+NodeScore[i];        str+="\n";        str+=TopEdgeScore[0];        for(var i=1;i<VkeyTotal+OkeyTotal;i++) str=str+","+TopEdgeScore[i];        str+="\n";        for(var i=0;i<OkeyTotal;i++){                for(var e in EdgeScore[i]){                    str=str+e+":"+EdgeScore[i][e]+",";                }            str+="\n";        }        str+=printRoot();		return str;	}    this.leastIndices=function(num,LEN){        var n=LEN.length;        var v1=new Array();        var i1=0;        var v2=new Array();        var ans=new Array();        var k=0;        var idx=new Array(n);        for(var i=0;i<n;i++) idx[i]=0;        v1[i1]=idx;        ans[k++]=idx;        var count=1;        while(true){            v2=plusOne(LEN,v1);            if(v2.length==0) break;            for(var i=0;i<v2.length;i++){                ans[k++]=v2[i];                count++;                if(count>=num) break;            }            v1=v2;            if(count>=num) break;        }        return ans;    }    function plusOne(LEN,v1){        var n=LEN.length;        var idx;        var j=0;        var a=0;        var ans=new Array();        for(var i=0;i<v1.length;i++){            idx=v1[i];            for(j=n-1;j>0;j--){                if(idx[j]!=0) break;            }            for(;j<n;j++){                if(idx[j]+1==LEN[j]) continue;                var idx2=new Array(n);                for(var k=0;k<n;k++) idx2[k]=idx[k];                idx2[j]++;                ans[a++]=idx2;            }        }        return ans;    }    this.setTarget=function(ex){        ex.state=(ex.state|5);        var pex=ex.parent;        while(pex!=null){            pex.state=(pex.state|1);            pex=pex.parent;        }    }    this.clearTarget=function(ex){        if(ex==null) return;        ex.state=(ex.state&2);        for(var i=0;i<ex.cnum;i++) this.clearTarget(ex.ch[i]);    }    this.clearAllTarget=function(ex){        var temp=ex;        while(temp.parent!=null){            temp=temp.parent;        }        this.clearTarget(temp);    }    this.searchTarget=function(ex){        if(ex==null) return null;        if((ex.state&5)==5) return ex;        var ans;        for(var i=0;i<ex.cnum;i++){            ans=this.searchTarget(ex.ch[i]);            if(ans!=null) return ans;        }        return null;    }};